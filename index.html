<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clase30-Backend06</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <h1>Clase28 Backend 4</h1>
    <section class="rest">
      <h2>Definición de REST</h2>
      <p>
        REST es un tipo de arquitectura de servicios que proporciona estándares
        entre sistemas informáticos para establecer como se van a comunicar
        entre sí
      </p>
      <p>
        Rest es una forma de construir servicios web de manera simple, coherente
        y escalable
      </p>
      <p>
        La transferencia de estado representacional (en inglés representational
        state transfer) o REST es un estilo de arquitectura software para
        sistemas hipermedia distribuidos como la World Wide Web. El término se
        originó en el año 2000, en una tesis doctoral sobre la web escrita por
        Roy Fielding, uno de los principales autores de la especificación del
        protocolo HTTP y ha pasado a ser ampliamente utilizado por la comunidad
        de desarrollo.
      </p>
      <article class="restServerApi">
        <h3>REST SERVER API</h3>
        <p>
          Cuando se envia una solicitud del cliente a través de una API de
          RESTful, esta transfiere una representación del estado del recurso
          requerido a quien lo haya solicitado o al extremo.
        </p>
        <p>
          La información, o representación, se entrega por medio de HTTP en uno
          de estos formatos
          <span
            >JSON (JavaScript Object Notation), HTML, XLT, Python, PHP o texto
            sin formato</span
          >.
        </p>
        <p>
          Los recursos que se utilizan en un sistema de RESTful se identifican
          con URLs. Cada recurso contiene su propia URL
          <span>Ej: localhost:3000/productos</span>.
        </p>
        <p>
          Asimismo, es necesario tener en cuenta otros aspectos. Los encabezados
          y los parámetros tambien son importantes en los métodos HTTP de una
          solicitud HTTP de la API de RESTful, ya que obtienen información de
          identificación importante con respecto a los metadatos, la
          autorización, el identificador uniforme de recursos (URI), el
          almacenamiento en caché, las cookies y otros elementos de la
          solicitud. Hay encabezados de solicitud y de respuesta, pero cada uno
          tiene sus propios códigos de estado e información de conexión HTTP.
        </p>
      </article>
      <article class="recursosUniformes">
        <h3>Recursos uniformes</h3>
        <p>
          Desde el lado del servidor, una <span>arquitectura REST</span> expone
          a los clientes a una interfaz uniforme.
        </p>
        <p>
          Todosl los recursos del servidor tienen un nombre en forma de URL o
          hipervínculo.
        </p>
        <p>
          Toda la info se intercambia a través del protocolo HTTP (los vervos
          http son get, post, put, delete)
        </p>
        <p>
          A esas URL les llamamos <span>endpoints</span>(http://..../productos),
          es decir, el servidor expone a los clientes un conjunto de endpoints
          para que sete pueda acceder(CRUD).
        </p>
        <p>
          A esa interfaz uniforme, o sea, al conjunto de endpoints, la llamamos
          <span>API</span>. Es toda la comunicación con el frontend, con
          backend; es todo el flujo de información. Ejemplo: Ofrezco un servicio
          a un frontend o backend del precio del dolar según la ciudad que este.
          Puedo ofrecer ese mismo servicio a otro backend (una empresa que
          importa para tener el valor del dolar actualizado).
        </p>
        <p>
          Un <span>endpiont</span> está ligado al recurso que solicitamos, dicho
          recurso debe tener solamente un identificador lógico, y este preveer
          acceso a toda la info relacionada.
        </p>
      </article>
    </section>
    <section class="API">
      <h2>Definicion de API</h2>
      <h3>¿Qué es una API?</h3>
      <p>
        Una <span>API</span> es un conjunto de definiciones y protocolos que se
        utiliza para desarrollar e integrar el software de las aplicaciones.
        Suele considerarse como el contrato entre el proveedor de información y
        el usuario, donde se establece el contenido que se necesita del
        consumidor <span>la llamada</span> y el que requiere el producto
        <span>la respuesta</span>.
      </p>
      <p>
        En otras palabras, se desea interactuar con una computadora o un sistema
        para obtener datos o ejecutar una función, las APIs le permiten
        comunicar lo que desea al sistema, para que este comprenda la solicitud
        y la cumpla.
      </p>
      <p>
        La API es el intermediario entre el servidor y el cliente. También está
        mal dicho que la API sería el servicio completo junto al servidor. Pero
        algunos cuando mencionan API hacen referencia a ese conjunto.
      </p>
      <h3>Para que una API se considere de RESTful</h3>
      <p>
        El cliente envía una petición (request). Los métodos HTTP son los verbos
        (GET, PUT, POST, DELETE). Estos se comunican bidireccionalmente con el
        Cliente en formato JSON. Los métodos se comunican con el Servidor y este
        manda una respuesta (response) de manera bidireccional en formato HTTP.
      </p>
      <p>
        En definitiva el Cliente envía una peticion JSON por medio de los
        métodos HTTP, estos a su vez le hacen llegar dicha peticion en formato
        HTTP. El servidor contesta dicha petición en formato HTTP por medio de
        los metodos HTTP y el cliente recibe la respuesta en formato JSON.
      </p>
      <p>Debe cumplir los siguientes criterios:</p>
      <ul>
        <li>
          Arquitectura cliente-servidor compuesta de clientes, servidores y
          recursos, con la gestión de solicitudes a través de
          <span>HTTP</span> (Métodos o Verbos HTTP, Get
          <span>Obtener</span> (otros dispositivos que se encuentran en la ruta
          como servers intermedios, routers, etc; pueden ver la información
          enviada por GET!), POST <span>Crear</span> (se envia un cuerpo con
          JSON y <span>el cuerpo no se ve</span> ideal para login), PUT
          <span>Actualizar</span> (se envia un cuerpo con JSON), DELETE
          <span>Borrar</span>
          ).
        </li>
        <li>
          <span>Comunicación entre el cliente y el servidor</span> sin estado,
          lo cual implica que la información del cliente no se almacena entre
          las solicitudes de <span>GET</span> y que cada una de ellas es
          independiente y está desconectada del resto. El servidor solo
          persistirán datos en la BD. El server no guarda info que no quede en
          la BD.
        </li>
        <li>
          Datos que pueden almacenarse en caché y
          <span>optimizan las itteracciones</span> entre el cliente y el
          servidor.
        </li>
        <li>
          Una <span>interfaz uniforme</span> entre los elementos, para que la
          información se transfiera de forma estandarizada.
        </li>
        <li>
          Un <span>sistemas de capas</span> que organiza en jerarquías
          invisibles para el cliente cada uno de los servidores que participan
          en la recuperación de la información solicitada.
        </li>
        <li>
          <span>Código disponible</span> según se solicite (opcional), es decir,
          la capacidad de enviar códigos ejecutables del servidor al cliente
          cuando se requiera, lo cual amplía las funciones del cliente.
        </li>
      </ul>
      <p>
        <a href="https://developer.mozilla.org/es/docs/Web/HTTP/Status"
          >Códigos de estado de respuesta HTTP</a
        >
      </p>
    </section>
    <section class="rutas">
      <article>
        <h2>Operaciones de las rutas</h2>
        <ul>
          <li>GET: Permite acceder a todos los datos del recurso.</li>
          <li>POST: Permite crear un nuevo recurso.</li>
          <li>
            PUT: Reemplaza un recurso ya existente (reemplaza todo el recurso)
          </li>
          <li>
            PATCH: Actualiza o modifica parcialmente a un recurso ya existente.
          </li>
          <li>DELETE: Permite indicar al servidor que borre un recurso.</li>
        </ul>
      </article>
      <article>
        <h3>¿Qué nos devuelven los URLs?</h3>
        <p>
          Cuando accedemos a una URL de nuestra API, esta nos suele devolver
          datos en formato JSON.
        </p>
        <p>Algunos de esos datos son:</p>
        <ul>
          <li>
            Una <span>clave link</span> que apunta al mismo endpoint al que
            acabamos de acceder.
          </li>
          <li>Información genérica (Ej: cantidad de datos)</li>
          <li>
            Datos básicos de la petición y otros endpoints para acceder a más
            detalles.
          </li>
        </ul>
      </article>
    </section>
    <!-- 40:40 -->
    <section class="mvc">
      <article>
        <h2>MVC</h2>
        <h3>Definición</h3>
        <p>
          Es un patrón de diseño. Sus siglas corresponden a
          <span>Modelo Vista Controlador</span>.
        </p>
        <h3>¿Qué es un patrón de diseño?</h3>
        <p>
          Dentro del mundo de la programación existen lo que se conocen como
          patrones de diseño. Los mismos proponen un esquema de trabajo, una
          serie de reglas que permiten simplificar el código y encarar mejor la
          solución de diferentes situaciones a lo largo del desarrollo.
        </p>
        <p>
          Su objetivo es crear aplicaciones modulares, dividiendo la columan
          vertebral del proyecto en tres componentes principales, en donde cada
          uno de ellos cumple con un rol determinado.
        </p>
        <p>
          Estos componentes son:
          <span>los modelos, las vistas y los controladores</span>.
        </p>
        <p>
          La vista (UI: Interfaz de usuario) representa el estado actual del
          modelo. Conforman la interfaz gráfica de la aplicación y contienen
          todos los elementos que son visibles al usuario. A través de ellas el
          usuario interactúa enviando y solicitando información al servidor. Su
          responsabilidad es definir la apariencia de los datos y mostrarlos en
          pantalla. Las vistas no se comunican de forma directa con los modelos.
        </p>
        <p>
          El modelo representa a la lógica de los datos: Conforman y contienen
          la lógica de la aplicación. Sus responsabilidades son conectarse con
          la base de datos. Los modeles no se comunican de forma directa a las
          vistas.
        </p>
        <p>
          El controlador controla y decide como se mostrarán los datos:
          Conforman la capa intermedia entre las vistas y los modelos. Su
          responsabilidad es procesar los datos que recibe de los modelos y
          elegir la vista correspondiente en funcion de aquellos datos. Tienen
          relación directa con las vistas y con los modelos y es un componente
          fundamental dentro del flujo del patrón. Administra lo que se conoce
          como la lógica de negocio.
        </p>
        <p>
          La vista y el modelo
          <span
            >no se conectan de manera directa, solo a través del
            controlador</span
          >
        </p>
      </article>
      <article>
        <h2>Explicacion MVC</h2>
        <h5>
          <a
            href="https://www.freecodecamp.org/espanol/news/el-modelo-de-arquitectura-view-controller-pattern/"
            >Fuente</a
          >
        </h5>
        <p>
          El patrón de arquitectura MVC convierte el desarrollo de aplicaciones
          complejas en un proceso mucho más manejable. Permite a varios
          desarrolladores trabajar simultáneamente en la aplicación.
        </p>
        <img src="./assets/MVC3.png" width="600px" alt="MCV" />
        <h3>¿Por qué deberías usar MVC?</h3>
        <p>
          Tres palabras: separación de preocupaciones (separation of concerns),
          o SoC para abreviar.
        </p>
        <p>
          El patrón MVC te ayuda a dividir el código frontend y backend en
          componentes separados. De esta manera, es mucho más fácil administrar
          y hacer cambios a cualquiera de los lados sin que interfieran entre
          sí.
        </p>
        <p>
          Pero esto es más fácil decirlo que hacerlo, especialmente cuando
          varios desarrolladores necesitan actualizar, modificar o depurar una
          aplicación completada simultáneamente.
        </p>
      </article>
      <article>
        <h2>Ejemplo de una concesionaria</h2>
        <p>Tengo personal: administrativos, venderores y gerentes</p>
        <p>Tengo autos y motos de distintos modelos</p>
        <p>Tengo sucursales de la concesionaria en distintas ciudades</p>
        <p>
          Tengo un modelo de datos
          <span
            >modelo porque es una representación simplificada de la
            realidad</span
          >
          en la que se guardará todo tipo de datos que necesita la concesionaria
          para su correcto funcionamiento, y este modelo de datos estará
          plasmado en una aplicación que use la empresa.
        </p>
        <p>
          El controlador recibirá las peticiones y el que de las respuestas a la
          vista, el controlador controlará las peticiones como sus respuestas.
          Cuando reciba una petición pedirá al modelo de datos la información
          que necesita, el controlador ordenará los datos y se los presentará a
          la vista para que los muestre (la vista se encargue de mostrarlo).
        </p>
      </article>
    </section>
    <section class="flujo">
      <h2>Flujo del Server</h2>
      <article>
        <h3>1. app.js</h3>
        <h4>Empezamos por el archivo principal</h4>
        <p>
          Es el archivo principal donde levanta el servidor. Nota:
          <span>
            en este archivo no hay mucho código, solo la instancia del server y
            el método listen.
          </span>
        </p>
      </article>
      <article>
        <h3>2. server.js</h3>
        <h4>Nuestra clase server</h4>
        <p>
          En una carpeta <span>models</span> creamos el archivo server.js que
          contendrá nuestro "molde" del server. Tiene la siguiente estructura:
        </p>
        <ul>
          <li>constructor</li>
          <li>middlewares</li>
          <li>routes</li>
          <li>listen</li>
        </ul>
      </article>
      <article>
        <h3>3. Routes</h3>
        <h4>Carpeta con nuestras rutas</h4>
        <p>En esta carpeta pondremos todas las rutas de nuestro server:</p>
        <ul>
          <li>get</li>
          <li>post</li>
          <li>put</li>
          <li>delete</li>
        </ul>
      </article>
    </section>
    <section class="instalarServidor">
      <h2>instalar el servidor</h2>
      <pre><code>

                  npm init

                  configurar package.json

                  En el script del archivo package.json: 
                    "scripts": {
                    "test": "echo \"Error: no test specified\" && exit 1",
                    "start": "node server.js",
                    "dev":"nodemon server.js"
                  
                  instalar nodemon
                  npm install -g nodemon # or using yarn: yarn global add nodemon
                  
                  
                  npm install express

                  para ejecutar el servidor estable es con node 
                        npm start

                  para ejecutar el servidor de pruebas con nodemon
                        npm run dev
      </code></pre>
      <p>Código en el archivo server.js</p>
      <pre><code>
        // este es el archivo principal que levanta al servidor

        // importar el modulo express
        const express = require('express');

        // app de mi servidor -> retorno de express ejecutado como una función
        const app = express();

        // configuro el puerto de salida del servidor en 3000
        const port = 3000;

        //listen: método de escuchar (inicio del funcionamiento del servidor)
        app.listen(port, () => {
            console.log(`App funcionando en el puerto ${port}`);
        })
      </code></pre>
    </section>
    <section class="aplicacionFlujo">
      <h2>Aplicación del Flujo del Servidor</h2>
      <h3>Archivo "package.json"</h3>
      <p>
        Una vez configurado este archivo quedará de una manera similar a esta:
      </p>
      <pre>
        <code>
        {
            "name": "express",
            "version": "1.0.0",
            "description": "",
            "main": "index.js",
            "scripts": {
                "test": "echo \"Error: no test specified\" && exit 1",
                "start": "node server.js",
                "dev": "nodemon server.js"
            },
            "author": "",
            "license": "ISC",
            "dependencies": {
              "express": "^4.18.2"
            }
        }
        </code>
      </pre>
      <h3>Archivo "server.js"</h3>
      <p>
        Importo el modulo express, importo las funciones declaradas en app.js.
      </p>
      <pre><code>
        // este es el archivo principal que levanta al servidor

        // importar el modulo express
        const express = require('express');

        //importo app desde app.js
        const app = require('./app');

        // app de mi servidor -> retorno de express ejecutado como una función
        //const app = express();

        // configuro el puerto de salida del servidor en 3000
        const port = 3000;

        //listen: método de escuchar (inicio del funcionamiento del servidor) 
        // listen viene de la libreria de express
        // cuando llamo a app viene el código desde ./app.js
        app.listen(port, () => {
            console.log(`App funcionando en el puerto ${port}`);
        })
      </code></pre>
      <h3>Archivo app.js</h3>
      <pre><code>
        // importar el modulo express
        const express = require('express');
        // app de mi servidor -> retorno de express ejecutado como una función
        const app = express();
        // parseo a json para que pueda procesar get, put, delete y post
        app.use(express.json());
        // importo las funciones que se declaran en task
        const taskRouter = require('./routes/task');
        // asigno la ruta http://localhost:3000/tasks
        app.use('/tasks', taskRouter);
        // exporto app par que todos puedan acceder a este archivo (app.js)
        module.exports = app;
      </code></pre>
    </section>
    <section>
      <h3>Archivo "/routes/task.js"</h3>
      <pre><code>
          // importo express
          const express = require('express');
          // importo rutas, este sera el administrador de las rutas
          const router = express.Router();
          // importo las funciondes declaradas desde taskController
          const taskController = require('../controllers/taskController');
          const { route } = require('../app');

          // en app.js uso el endpoint /tasks  -> todos las tareas
          router.get('/', taskController.getTasks)

          // tareas por id
          router.get('/:id', taskController.getTaskByID)

          // buscar tarea por nombre de tarea
              // localhost:3000/tasks/tarea/hac  
              // -> { "id": "3", "tarea": "hacer las compras", "hecha": false }
          router.get('/tarea/:tarea', taskController.getTaskByTarea)

          //agregar una tarea
          router.post('/', taskController.createTask);

          //actualizar una tarea por id
          router.put('/:id', taskController.updateTask);

          //eliminar un registro
          router.delete('/:id', taskController.deleteTask);

          //exporto el modulo para que sea visible al resto del proyecto
          module.exports = router;

          // este proyecto puede ser virtualizado con la herramienta 
          //THUNDER CLIENT DISPONIBLE EN CODE.
      </code></pre>
    </section>

    <section>
      <h3>Archivo "/controllers/taskController.js</h3>
      <pre>
        <code>
          // el controlador se encarga del procesamiento de los datos para que se muestren
          // creo la BD, cada vez que inicio el server los datos que se carguen, 
          // se actualicen o borren
          // se perderán solo quedarán los datos que se declaran en este arreglo.
          // let para poder modificar el arreglo
          let taskDB = [
              { id: 1, tarea: 'tarea1', hecha: false },
              { id: 2, tarea: 'tarea2', hecha: false },
              { id: 3, tarea: 'hacer las compras', hecha: false },
              { id: 4, tarea: 'estudiar para el examen', hecha: true },
              { id: 5, tarea: 'trabajar', hecha: false }
          ];


          // funcion para obtener los datos (en este caso se trata de tareas)
          // dentro de la funcion el response le asigno un status 200 (server funcionando ok)
          // y devuelvo la BD en formato Json al cliente.
          const getTasks = (req, res) => {
              res.status(200).json({ taskDB })
          }

          // obtener las tareas por id, virtualiza con Thunder Client
          // colllections pepe -> new request (body para json)
          const getTaskByID = (req, res) => {
              const idRecibido = req.params.id;
              // PRUEBA: muestro el tipo de dato "numero" 
              //         que se recibe no es un numero

              // if (isNumberObject(idRecibido)) {
                  // res.send(`${idRecibido} es un numero`)
              // } else {
                  // res.send(`${idRecibido} no es un numero`)
              // }
              //buscar en el array
              const taskSearch = taskDB.find(tarea => tarea.id == idRecibido);
              //res.send(taskSearch);

              // si la busqueda fue exitosa o no
              if (taskSearch) {
                  res.status(200).json({ task: taskSearch, msg: 'Ok' })
              } else {
                  // ojo con los tipos
                  res.status(404).json({ task: null, msg: 'Recurso no encontrado' })
              }
          }

          // busqueda no texto 
          const getTaskByTarea = (req, res) => {
              // recibo el texto por params  .../tarea/:tarea
              const tareaAbuscar = req.params.tarea;

              // paso a minusculas todo el texto que se encuentra en tarea
              // que tenga incluido en su texto el parametro pasado
              const taskTarea = taskDB.filter(item => item.tarea.toLowerCase().includes(tareaAbuscar.toLowerCase()))

              // si la busqueda fue exitosa o no
              if (taskTarea) {   // task es el objeto que se muestra por pantalla 
                                // y taskTarea es el objeto creado con filter
                  res.status(200).json({ task: taskTarea, msg: 'Ok' })
              } else {
                  // ojo con los tipos
                  res.status(404).json({ task: null, msg: 'Recurso no encontrado' })
              }
          }

          // crear una tarea
          const createTask = (req, res) => {
              // tarea corresponde al atributo de taskDB, 
              // si se cambia el nombre "tarea" no se agregará al objeto
              // el body lo voy a agregar a la lista de tareas (objeto)
              const { tarea } = req.body;
              
              // creo una constante tarea nueva de como
              // quedaría el dato en el objeto (todavia no se sube)
              const tareaNueva = {
                  id: taskDB.length + 1,
                  tarea: tarea,
                  hecha: false
              }

              // agrego la tarea al objeto
              taskDB.push(tareaNueva);

              // esta parte actualizará la BD taskDB y el dato pusheado quedará guardado en la BD
              // en caso de ignorar este comando, el sistema quedará en un bucle infinito,
              // posteriormente lanzara un mensaje de error:
              // "Connection was forcibly closed by a peer."

              //status 201 porque agrego algo 201 recurso creado
              res.status(201).json({taskDB, msg : 'Tarea agregada exitosamente'})

          }

          // actualizar una tarea SOLO EL NOMBRE DE LA TAREA
          const updateTask = (req, res) => {
              // recibo el id a modificar -> localhost:3000/task/1 -> id=1
              const id = Number(req.params.id);
              // buscar el registro que coincida con el id ingresado
              let task = taskDB.find(tarea => tarea.id === id);
              
              
              if (task) {
                  // si encuentro la tarea actualizo contenido de la tarea
                  // cargo la tarea (a modificar) que se encuentra en el body
                  const { tarea } = req.body;
                  // modifico la variable (declarada con let)
                  task = { ...task, tarea: tarea }
                  // nuevo arreglo de tareas que no coincidan con el id del parametro
                  const newTaskArray = taskDB.filter(task => task.id !== id);
                  //defino de nuevo la BD con la newTaskArray + task
                  taskDB = [...newTaskArray, task];
                  res.status(200).json({ task: task, msg: 'Tarea actualizada exitosamente!' })
              } else {
                  res.status(404).json({ task: null, msg: 'Recurso no encontrado' })
              }
          }

          const deleteTask = (req, res) => {
              // recibo el id a modificar -> localhost:3000/task/1 -> id=1
              // Number()  es igual que parseInt()
              const id = parseInt(req.params.id);
              // buscar el registro que coincida con el id ingresado
              let task = taskDB.find(tarea => tarea.id == id);
              // si encuentro la tarea la borro
              if (task) {
                  // reemplazo todos los registros 
                  // sin el id (que quiero borrar)
                  // al mismo bd
                  taskDB = taskDB.filter(task => task.id !== id);
                  res.status(200).json({taskDB, msg: 'Tarea eliminada exitosamente!'})
              } else {
                  res.status(404).json({ task: null, msg: 'Recurso no encontrado' })
              }
          }


        // exporto getTasks para que otros modulos tengan acceso (en este caso task.js)
        // module.exports = funcion;  -> exporto solo una función
        // module.exports = { funciones };  -> exporto mas de una función
        module.exports = { getTasks, getTaskByID, getTaskByTarea, createTask, updateTask, deleteTask };
        </code>
      </pre>
      <h3>Ejemplo de Thunder Client</h3>
      <img
        src="./assets/THUNDER-CLIENT.png"
        width="600px"
        alt="thunder client"
      />
      <p>y el codigo completo:</p>
      <pre>
        <code>
          {
          "client": "Thunder Client",
          "collectionName": "la-costa",
          "dateExported": "2024-01-18T23:55:40.960Z",
          "version": "1.1",
          "folders": [],
          "requests": [
              {
                  "_id": "824c4765-498a-42a0-90b4-d94a79d40e99",
                  "colId": "3e412e57-7b9d-4458-a98f-eb348d0d1902",
                  "containerId": "",
                  "name": "listar todas las tareas",
                  "url": "localhost:3000/tasks",
                  "method": "GET",
                  "sortNum": 50000,
                  "created": "2024-01-17T11:38:45.326Z",
                  "modified": "2024-01-17T22:23:46.375Z",
                  "headers": [],
                  "params": [],
                  "body": {
                      "type": "json",
                      "raw": "{\n  \"tarea\":\"nueva tarea\"\n}",
                      "form": []
                  },
                  "tests": []
              },
              {
                  "_id": "2e4d7ca7-6ba2-480a-af77-3894f77487e5",
                  "colId": "3e412e57-7b9d-4458-a98f-eb348d0d1902",
                  "containerId": "",
                  "name": "tarea por id",
                  "url": "localhost:3000/tasks/6",
                  "method": "GET",
                  "sortNum": 60000,
                  "created": "2024-01-17T13:30:59.590Z",
                  "modified": "2024-01-17T16:30:03.521Z",
                  "headers": [],
                  "params": [],
                  "tests": []
              },
              {
                  "_id": "76bdda59-5df3-437a-852e-775c5fd80f1f",
                  "colId": "3e412e57-7b9d-4458-a98f-eb348d0d1902",
                  "containerId": "",
                  "name": "consulta tarea por nombre",
                  "url": "localhost:3000/tasks/tarea/A",
                  "method": "GET",
                  "sortNum": 70000,
                  "created": "2024-01-17T16:32:49.603Z",
                  "modified": "2024-01-18T23:54:51.391Z",
                  "headers": [],
                  "params": [],
                  "tests": []
              },
              {
                  "_id": "7d1763b9-0fd7-4a35-a902-a6ca4ea272b1",
                  "colId": "3e412e57-7b9d-4458-a98f-eb348d0d1902",
                  "containerId": "",
                  "name": "nueva tarea",
                  "url": "localhost:3000/tasks/",
                  "method": "POST",
                  "sortNum": 80000,
                  "created": "2024-01-17T17:18:17.934Z",
                  "modified": "2024-01-17T17:24:18.267Z",
                  "headers": [],
                  "params": [],
                  "body": {
                      "type": "json",
                      "raw": "{\n  \"tarea\": \"Una nueva tarea\"\n}",
                      "form": []
                  },
                  "tests": []
              },
              {
                  "_id": "fdfd8c49-3016-4482-8a4b-d62f53cadec1",
                  "colId": "3e412e57-7b9d-4458-a98f-eb348d0d1902",
                  "containerId": "",
                  "name": "actualizar tarea",
                  "url": "localhost:3000/tasks/6",
                  "method": "PUT",
                  "sortNum": 90000,
                  "created": "2024-01-18T02:23:01.011Z",
                  "modified": "2024-01-18T19:40:53.961Z",
                  "headers": [],
                  "params": [],
                  "body": {
                      "type": "json",
                      "raw": "{\n  \"tarea\": \"La sexta tarea!!!!\"\n}",
                      "form": []
                  },
                  "tests": []
              },
              {
                  "_id": "e6cd9e65-bd48-431e-a8e1-f9a175a1e5ca",
                  "colId": "3e412e57-7b9d-4458-a98f-eb348d0d1902",
                  "containerId": "",
                  "name": "eliminar una tarea",
                  "url": "localhost:3000/tasks/6",
                  "method": "DELETE",
                  "sortNum": 100000,
                  "created": "2024-01-18T22:12:37.820Z",
                  "modified": "2024-01-18T22:16:29.512Z",
                  "headers": [],
                  "params": [],
                  "tests": []
              }
          ]
      }
        </code>
      </pre>
    </section>
    <section>
      <h2>Continuacion del proyecto en la Clase 29</h2>
      <article>
        <h3>MVC y Cliente HTTP</h3>
        <p>Implementamos en nuestro código este patrón</p>
        <ul>
          <li>carpeta models</li>
          <li>carpeta routes</li>
          <li>carpeta controllers</li>
        </ul>
        <p>
          Donde en la carpeta models tendremos nuestra clase server (no se hara
          un servidor con clases), en la carpeta routes alojaremos todas las
          rutas de nuestra API, y en la carpeta Controllers tiene todos los
          controladores para las rutas correspondientes.
        </p>
        <p>
          Entre el modelo y la vista está el controlador. Desde la vista llegan
          las peticiones al controlador, el controlador le envia las peticiones
          al modelo para que trabaje, por último el modelo responde al
          controlador y este le envia la respuesta a la vista.
        </p>
      </article>
      <article>
        <h3>Comnunicaciones entre Front y Back</h3>
        <p>
          En el backend vamos a estar esperando las solicitudes del frontend
          (desde fetch o axios)
        </p>
        <p>
          Tambien Axios se puede utilizar en el backend para comunicarse a otra
          API Rest sea externa o interna
        </p>
        <p>
          Hay veces que se realizan consultas desde el front que pueden no tener
          cuerpo (con body como post sin body con get); con post en el body va
          un JSON y en la base de datos se termina guardando o modificando
          cierta información o con get se pide cierta información, por ultimo se
          da una respuesta del exito o el fracaso de la accion y la app del
          cliente muestra el mensaje.
        </p>
        <p>
          Si nuestra app es dinámica, cuando un usuario entre desde su
          navegador, realizará una solicitud de HTTP, por ejemplo, para que se
          muestre el listado de los productos.
        </p>
        <p>
          El usuario ingresa a nuestra aplicación desde su navegador. Lo que se
          muestra en el frontend es lo que esta desarrollado en React. Éste
          envia la solicitud del usuario al backend. El backend es la API REST,
          es lo que ha sido desarrollada en NodeJS. Node le pide a la Base de
          Datos la informacion requerida por el usuario y la envia en formato
          JSON al frontend como respuesta.
        </p>
      </article>
      <article>
        <h3>Cliente HTTP</h3>
        <p>
          El cliente HTTP es el encargado de abrir una sesión HTTP y de enviar
          la solicitud de conexion al servidor.
        </p>
        <p>
          Hay varias formas de realizar solicitudes HTTP en Node a través de
          clientes HTTP. Existen dos tipos prinicipales de clientes:
        </p>
        <ul>
          <li>
            Internos: módulos HTTP o HTTPS estándar que vienen en la librería de
            NodeJS (fetch)
          </li>
          <li>
            Externos: paquetes de NPM (axios o Got) instalables como cualquier
            módulo
          </li>
        </ul>
      </article>
      <article>
        <h3>axios</h3>
        <p>
          axios es una biblioteca de solicitudes muy popular basada en promesas.
        </p>
        <p>
          Es un cliente HTTP disponible tanto para el navegador como para NodeJS
        </p>
        <p>
          Incluye también funciones útiles como interceptar datos de solicitud y
          respuesta, y la capacidad de transformar automáticamente los datos de
          solicitud y respuesta a JSON
        </p>
        <p>Lo empezamos a usar instalando el módulo de axios</p>
        <pre><code>npm i axios</code></pre>
      </article>
      <article>
        <h3>axios - Petición GET</h3>
        <p>
          Para realizar una petición por GET al servidor usando axios, vamos a
          ver dos ejemplos posibles (promesas)
        </p>
        <h4>Definir el ID como query en la url</h4>
        <pre><code>
          const axios = require('axios')
          axios.get('/user?ID=32')
            .then(function(response:any){
              console.log(response)
            })
            .catch(function(error:any){
              console.log(error)
            })
        </code></pre>
        <h4>Definir en la propiedad params</h4>
        <pre><code>
          const axios = require('axios')
          axios.get('/user',{
            params: {
              ID:32
            }
          })
            .then(function(response:any){
              console.log(response)
            })
            .catch(function(error:any){
              console.log(error)
            })
        </code></pre>
        <p>
          Además, al funcionar con promesas, podemos usar la sintaxis de
          Async/Await: (Se recomienda)
        </p>
        <pre><code>
          const axios = require('axios')

          const getUserId = async () => {
            try {

              const response = await axios.get('/user?ID=32')
              console.log(response)
            
            } catch (error) {

              console.log(error)

            }
          }
        </code></pre>
      </article>
      <article>
        <h3>Rutas</h3>
        <p></p>
      </article>
      <article>
        <h3>Postman</h3>
        <p>Es una forma más profesional que cliente HTTP.</p>
      </article>
      <article>
        <h3>Middlewares</h3>
        <h4>Definición</h4>
        <p>
          Un middleware es un bloque de código que se ejecuta
          <span>entre</span> la petición que hace el usuario (request) hasta que
          la petición llega al servidor.
        </p>
        <p>
          También un middleware es un bloque de código que se ejecuta
          <span>entre</span> la respuesta que hace el servidor (response) hasta
          que la respuesta llegue al cliente.
        </p>
        <img
          src="./assets/ExpressJS_Middleware_1.webp"
          width="600px"
          alt="grafico middleware"
        />
        <img
          src="./assets/middleware-infographic.webp"
          width="600px"
          alt="infografía middleware"
        />
        <h4>
          Las funciones de middleware pueden realizar las siguientes tareas:
        </h4>
        <ul>
          <li>Ejecutar cualquier código</li>
          <li>Realizar cambios en la solicitud y los objetos de respuesta</li>
          <li>Finalizar el ciclo de solicitud/respuestas</li>
          <li>
            Invocar la siguiente función de middleware que se encuentra en la
            pila
          </li>
        </ul>
        <h4>
          Nota: Se debe invocar a next() para pasar el control a la siguiente
          funcion de middleware. De lo contrario la solicitud quedará colgada.
        </h4>
        <img
          src="./assets/express-middleware-next.webp"
          width="600px"
          alt="función next del middleware"
        />
        <img
          src="./assets/comunicacionMiddleware.png"
          width="600px"
          alt="Secuencia comunicacion cliente servidor middleware"
        />

        <p>
          Middleware generalmente funcionan como filtro y si no corresponde
          devuelve al cliente una respuesta. En caso que esté bien la peticion
          (ejemplo el usuario existe pasa al siguiente middleware y si no
          retorna al cliente un mensaje de error. Otro ejemplo de middleware sería 
          que el server una vez logueado el usuario le entregue a este un token y con ese 
          token habrá un middleware que verifique si el token es válido.)
        </p>
        <h3>Tipos de Middleware</h3>
        <ul>
          <li>Middleware a nivel aplicación</li>
          <li>Middleware a nivel del Router</li>
          <li>Middleware de manejo de errores</li>
          <li>Middleware incorporado</li>
          <li>Middleware de terceros</li>
        </ul>
        <h3>Middleware a nivel aplicación</h3>
        <pre><code>
          // CORS
          app.use(cors());

          // lectura y parseo del body
          app.use(espress.json());
        </code></pre>
          <h3>Middleware a nivel del Router</h3>
          <pre><code>
            router.get('/', MIDDLEWARE, usuariosGet);
          </code></pre>
          <h3>Middleware de manejo de errores</h3>
          <p>Estas funciones se definen de la misma forma que otras funciones de middleware, 
            excepto que llevan cuatro argumentos en lugar de tres, específicamente con la firma 
            (err, req, res, next):
          </p>
          <pre><code>
            app.use(function(err, req, res, next) {
              console.log(err.stack);
              res.status(500).send('Something broke!');
            });
          </code></pre>
          <h3>Middleware incorporado</h3>
          <pre><code>
            // Directorio público

            app.use(express.static('public'))
          </code></pre>
          <h3>Middleware de terceros</h3>
          <p>Podemos <span>instalar y utilizar Middleware de terceros</span> para añadir funcionalidad
            a nuestra aplicación. El uso puede ser a <span>nivel aplicación o nivel Router</span>. 
            Por ejemplo, instalamos y usamos la función de middleware de análisis de cookies 
            <span>cookie-parser</span>. 
          </p>
          <pre><code>
            $ npm install cookie-parser 

            var express = require('express');
            var app = express();
            var cookieParser = require('cookie-parser');

            // leer el middleware cookie-parser
            app.use(cookie-parser());
          </code></pre>
      </article>
      <article>
        <h3>CORS</h3>
        <p>
          Intercambio de recursos de origen cruzado (CORS), es un mecanismo para
          permitir o restringir los recursos solicitados en un servidor web
          dependiente de donde se inició la solicitud HTTP. (El cors me sirve
          que si tengo un backend ese cors solo funcione en mi pagina web o en
          una lista de paginas web no en todas las paginas web que quieran
          acceder al servicio, por ejemplo 500 solicitudes diarias que tiene
          para mostrar la cotizacion de una moneda. Si otro lo usa, me quedo sin
          servicio a la mitad del dia.)
        </p>
        <p>
          Esto se utiliza para proteger un determinado servidor web del acceso
          de otro sitio web o dominio. Por ejemplo, solo los dominios permitidos
          podrán acceder a los archivos alojados en el servidor, como una hoja
          de estilo, una imagen, un script.
        </p>
        <p>
          Por razones de seguridad, los navegadores restingen las solicitudes
          HTTP de origen cruzado iniciadas dentro de un script.
        </p>
        <p>
          Por ejemplo, si nos encontramos en
          <span>http://example.com/page1</span> y estamos haciendo referencia a
          una imagen de <span>https://image.com/image1.jpg</span>, no se podrá
          recuperar esa imagen a menos que
          <span>https://image.com</span> permita compartir origenes cruzados con
          <span>http://example.com</span>.
        </p>
      </article>
      <article>
        <h3>Resumen</h3>
        <p></p>
      </article>
    </section>
    <section>
      <article>
        <h3>01. ¿Qué es MONGODB?</h3>
        <p>MongoDB es una base de datos orientada a documentos. Esto quiere decir que en lugar 
          de guardar los datos en registros, guarda los datos en documentos. Estos documentos 
          son almacenados en JSON.
        </p>
        <p>
          Una de las diferencias más importantes con respecto a las bases de datos relacionales, es que 
          no es necesario seguir un esquema. Los documentos de una misma colección (concepto similar 
          a una tabla de una base de datos relacional), pueden tener esquemas diferentes.
        </p>
        <h3>02. Características</h3>
        <h4>Generales</h4>
        <ul>
          <li>Almacena datos en documentos flexibles similares a JSON, la estructura de datos 
            puede cambiarse con el tiempo. Ejemplo cada usuario en vez de 
            registrarse debiera documentarse. Carecen de estructura definida, en un documento 
            podria tener nombre domicilio y el el siguiente nombre, domicilio y telefono.
          </li>
          <li>El modelo de documento se asigna a los objetos en el código de su aplicación 
            para facilitar el trabajo con los datos.
          </li>
          <li>MongoDB es una base de datos distribuida en su núcleo, por lo que la 
            alda disponibilidad, la escalabilidad horizontal y la distribución geográfica 
            estan integradas y son fáciles de usar. Las bases de datos relacionales consumen
            muchos mas recursos en el servidor (almacenamiento y poder de calculo) que una 
            base de datos no relacional. MongoDB tienen servidores en todo el mundo.

          </li>
          <li>Es de uso gratuito</li>
        </ul>
        <h3>03. Concepto</h3>
        <p>El concepto de bases de datos NoSQL va creciendo y se utiliza con más frecuencia.</p>
        <p>El concepto NoSQL define sistemas que difieren del modelo clásico SQL. Lo más destacado 
          de NoSQL es que no usan SQL como lenguaje principal de consultas.
        </p>
        <p>
          MongoDB es una base de datos orientada a documentos. No se basa en el concepto de tabla, 
          fila y registro sino que se apoya en el concepto de <span>Colección, Documento y Propiedad</span>.
        </p>
        <h3>05. Arquitectura (en la diapo falta la 04)</h3>
        <img src="./assets/mongo01.png"  width="400px"  alt="Imagen del Servidor MongoDB">
        <h3>06. Diferencias</h3>
        <ul>
          <li>Aquí comienzan las diferencias importantes entre una base de datos SQL y una 
            NoSQL. El concepto de fila y de documentos son bastante diferentes.
          </li>
          <li>
            Una fila está compuesta de columnas y siempre son las mismas para todas ellas.
          </li>
          <li>
            En cambio un documento está compuesto por claves y valores y cada documento puede 
            tener variaciones importantes con respecto al anterior dentro de una colección.
          </li>
        </ul>
        <h3>07. Ejemplo (en la diapo falta la 06)</h3>
        <img src="./assets/SQL-NoSQL.png"  width="600px" alt="diferencias sql y no sql">
        <p>Las bases de datos relacionales tienen relaciones e indices y por lo tanto gastan más 
          recursos en su manuntención.
        </p>
        <p>Las bases de datos no relacionales o en este caso NoSQL la relacion la tengo que definir 
          en otra colección especial para ello.
        </p>
        <h3>08. Ventajas y desventajas</h3>
        <div>
          <div>
            <h4>Ventajas</h4>
            <ul>
              <li>La escalabilidad y su carácter descentralizado hacen que 
                soporte estructuras distribuidas. Ej: puedo acceder a una base de datos en 
              la nube (chile o brasil)</li>
              <li>Permiten realizar sistemas más abiertos y flexibles debido a su fácil 
                adaptación de nuevas evoluciones de nuestras aplicaciones web</li>
              <li>No se requieren potentes recursos para poder trabajar con bases de datos NoSQL</li>
              <li>Optimización de las consultas en base de datos para grandes cantidades 
                de datos almacenados</li>
            </ul>
          </div>
          <div>
            <h4>Discusión</h4>
            <ul>
              <li>Problemas con sentencias SQL ya que no admiten el 100% de las 
                consultas existentes.</li>
              <li>Carece de algo tan fundamental como los Joins. Las relaciones se hacen a mano.</li>
              <li>Falta de estandarización entre diferentes bases de datos NoSQL</li>
            </ul>
          </div>
        </div>
      </article>
      <article>
        <h2>Utilización de mongoose - Objeto de modelado elegante de mongodb para node.js</h2>
        <p>Mongoose es una librería (ODM - Object Document Mapping) para MongoDB. Mongoose abstrae 
          tode de la base de datos, y el código de la aplicacion interactúa solo con los objetos y 
          sus métodos. Los ODM también permiten especificar las relaciones entre diferentes tipos 
          de objetos y poner sobre estos lógica dentro de clases.
        </p>
        <p>ODM es un asistente para trabajar con MongoDB de manera sencilla. Para instalarlo en el 
          proyecto que vamos a utilizar:
        </p>
        <pre><code>
          $ npm install mongoose  
          $ npm install dotnenv -> crear en la '/' (raiz) del proyecto un archivo ".env"
        </code></pre>
        <p>El archivo .env (dotenv) se usará para guardar la info sensibles como api keys que son llaves 
          que le dan las apis para poder tener acceso a esa api.
        </p>
        <p>
          En la pagina <a href="https://cloud.mongodb.com/">MongoDB</a> voy a Database (se encuentra 
          en el menú de la izquierda) y clickeo en la siguiente ruta <span>Database -> MongoDB for VS Code</span>
          copio la ruta que se genera en el punto 3 <span>mongodb+srv://patricio:MI-PASSWORD@cluster0.ncvbcji.mongodb.net/</span>
          MI-PASSWORD será reemplazada por la contraseña que tengo acceso a la pagina de MongoDB.
        </p>
        <h3>Archivo .env</h3>
        <p>En el archivo .env asigno una variable con el formato clave=valor (MONGO_URL = mongodb+srv:.... 
          sin comillas).</P>
          <span>NOTA: El archivo .env no se sube al repositorio!!!</span>

        <h3>Configurar la conexion en dbConnection.js</h3>
        <pre><code>
          // incluyo el módulo
          const mongoose = require('mongoose');

          // asi como esta incluyo el modulo dotenv NO SE GUARDA EN UNA VARIABLE  
          require('dotenv').config();

          // funcion para la conexion de la BD de mongoose asincrona
          // asincrona es porque tardará cierto tiempo en conectar la BD a un servidor remoto
          const dbConnect = async () => {
              try {
                  // que se conecte mongoose con los datos que se encuentran en .env
                  await mongoose.connect(process.env.MONGO_URL)
              } catch (error) {
                  Console.log('Error al conectarse a la base de datos: ' + error.message);
              }
          }

          module.exports = dbConnect;
        </code></pre>
        <h3>En el archivo app.js configuro: </h3>
        <pre><code>
          // importo la conexion
          const dbConnect = require('./database/dbConections');
          .....
          .....
          //luego de las rutas conecto a mongoDB (después del app.use)
          dbConnect();    // conectar a la base de datos
        </code></pre>
        <h3>Archivo taskController.js</h3>
        <p>Deshabilito el objeto que funcionaba como BD</p>
        <pre><code>
          // let taskDB = [
          //     { id: 1, tarea: 'tarea1', hecha: false },
          //     { id: 2, tarea: 'tarea2', hecha: false },
          //     { id: 3, tarea: 'hacer las compras', hecha: false },
          //     { id: 4, tarea: 'estudiar para el examen', hecha: true },
          //     { id: 5, tarea: 'trabajar', hecha: false }
          // ];
        </code></pre>
        <p>Mientras tanto en la página de mongodb cree una BD llamada taskDB y una colección 
          llamada tareas
        </p>
        <img src="./assets/mongo02.png" width="600px" alt="base de datos y coleccion en mongodb.com">
      </article>
    </section>
    <section>
      <h2>Creando un modelo</h2>
      <p>En Mongoose, <span>un Schema (Esquema)</span> es la estrucuta que indica cual es la forma en la 
      que están estructurados los <span>documentos</span> que se almacenan en una colección de MongoDB. 
      Cada schema esta <span>compuesto por campos y tipos de datos permitidos</span>, además de 
      opciones para llevar a cabo la validación de dichos documentos.</p>
      <img src="./assets/mongo03.png" width="600px" alt="Vista del esquema">
      <p>Nota: En cada documento se cargan los datos en el formato clave:valor.</p>
      <p>En la carpeta models crearé un archivo Task.js, el cual definiré el esquema que tendra cada documento</p>
      <pre><code>
        // impoto el modelo mongoose
        const mongoose = require('mongoose');
        const { type } = require('os');

        // clase "esquema" de mongoose (le da forma al modelo)
        const Schema = mongoose.Schema;

        // taskSchema será una instancia de Schema
        // que contendrá las tareas, en otras palabras estoy 
        // definiendo la estructura
        const taskSchema = new Schema({
            id: {
                type: String,     // tipo de datos que contendrá será caracter
                required: true,   // si se requiere que sea cargado se aclara que sea true (como por defecto es false no hace falta definir required en caso de que su valor sea falso.)
                unique: true
            },
            title: {
                type: String,
                required: true
            },
            description: {
                type: String,
                required: true
            },
            completed: {
                type: Boolean,
                default: false   // tarea completada tipo booleano y por defecto cargará el valor falso
            },
            createAt: {
                default: new Date().toLocaleDateString()      // default -> se generará automaticamente cuando se 
            },                                                   // cargue una nueva tarea a la coleccion

        })

        // con este clase voy a poder instanciar el modelo de tipo tarea e instanciarla en la base de datos.
        // clase que sirve para trabajar con el modelo Task (tarea)
        const Task = mongoose.model('Task', taskSchema); // nombre del modelo 'Task' y se cita el esquema (taskSchema)

        //exporto el modelo
        module.exports = Task;
      </code></pre>
      <img src="./assets/coleccion.png" width="100%" alt="">
      <p class="textoVerde">Nota: Para tener en cuenta, se debe respetar el endpoint con la coleccion de mongodb (deben ser iguales). </p>
      <p>La url a consultar: localhost:3000/tasks y La coleccion debe ser tasks</p>
      <p class="textoRojo">Nota: Para tener en cuenta, se puede apreciar el resultado a la izquierda que fue traido del sitio mongodb.com y a la derecha se puede apreciar la coleccion cargada en la base de datos (pagina de mongodb.com). </p>
      <p>El link suministrado por mongodb.com es MONGO_URL=mongodb+srv://TUusuario:TUcontraseña@cluster0.ncvbcji.mongodb.net/?retryWrites=true&w=majority</p>
      

    </section>
    <section>
      <h2>Clase 30 - Backend 06</h2>
      <h2>Schema en Mongoose, Express-validator y BScryptJS</h2>
      <h3>EXPRESS-VALIDATOR</h3>
      <P>Express-validator nos facilita, como lo dice su nombre, muchos middlewares para 
        que podamos validar el contenido de nuestras rutas. La documentación se encuentra 
        <a href="https://express-validator.github.io/docs">acá</a>. Para instalarlo:
      </P>
      <pre><code>
        $ npm install express-validator
      </code></pre>
    </section>
  </body>
</html>
<!-- 1:50:00  -->
