<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="shortcut icon" href="#" type="image/x-icon">
    <title>DOM</title>
    <link rel="stylesheet" href="style.css">
    
</head>
<body>
    <h2>Proceso, Memoria e Hilos</h2>
    <p>
        Un proceso es la instancia de un programa en ejecución. Es cuando las intrucciones (líneas de código) de un
        programa son ejecutadas por el procesador.
    </p>
    <p>
        Cada proceso por lo general tiene recursos asignados por él mismo y separados de otros procesos. 
        El proceso se almacena en memoria (stack o pila donde van las instrucciones, 
        heap o monticulo donde van el resto de los datos, variables, constantes y código).
    </p>
    <p>
        Un proceso puede crear múltiples hilos, un hilo (compuesto en memoria por un stack, codigo y registros; los registros se ejecutan en el cpu) es la secuencia de intrucciones más elemental 
        que puede ser manejada por el planificador del Sistema Operativo para ser ejecutadas. Cada hilo compartirá los recursos asignados al proceso, como las variables globales, el monticulo....
    </p>
    <p>
        Un hilo es la unidad más fundamental del proceso, es quien esta en contacto directo con el 
        cpu a la hora de ejecutar las instrucciones.
    </p>
    <p>
        Un proceso puede vrear otros procesos, relacion padre e hijo, los procesos hijos son independientes entre si, pero puden compartir recursos del padre.
    </p>
    <p>
        Un proceso puede vrear varios hilos, estos compartirán cierto contexto y recursos con el proceso que los creó y por lo tanto entre ellos. En JAVA se crea una clase que herede Thread.
    </p>
    <p>Fuente: <a href="https://www.youtube.com/watch?v=n6IxKTS2zYs" target="_blank">Ir a Youtube</a></p>

    <h2>Sincrónico</h2>
    <p>
        Las tareas se comienzan cuando la tarea previa finaliza.
    </p>
    <h2>JavaScript es Single Threaded y Sincrónico</h2>
    <p>
        Js solo puede hacer un comando o instrucción a la vez, en cada momento y en orden. 
        Cuando finaliza una orden comienza por la próxima. JavaScript se usa en conjunto a otros
        procesos y da la sensación de que todo ocurre al mismo tiempo....
    </p>
    <p>
        JS funciona en todas las computadoras porque es un sistema de un solo hilo y es un lenguaje
        liviano. Js tiene herramientas asíncronas. Que hay que declararlas como tal, una solicitud 
        a una base de datos remota para obtener información hay que hacerlo de manera asincrona. 
        El flujo de datos sería asi: asincrono (pedido), sincrono, sincrono, sincrono, asincrono (respuesta)
        No puedo trabajar con la respuesta hasta que llegue, de lo contrario la página mostrará un error.
    </p>
    <br>
    <section id="cuento"></section>
    <br>
    <p>
        Cada funcion que se ejecuta (inicio, introcuccion, desenlace y final) sigue un orden de forma sincrónica.
         Con esta "fila de funciones" se crea un <strong>stack o pila</strong>. Cuando el navegador llama distintos procesos 
         se acumulan en una <strong>pila de llamadas o CALL STACK</strong>. Es un apilamiento de funciones, 
         determinadas por la LIFO (última que ingresa, primero que sale). Como en este caso del cuento, como 
         las funciones son simples, entran y salen y por lo tanto no hay apilamiento. Hay apilamiento cuando
         las funciones son llamadas desde otra funcion (dependen una de otra) y ahí se produce el apilamiento.
         Ejecuta una funcion y retorna su callback. En la pila de funciones primero ingresa la callback, luego
         La funcion que la llamó, como sale primero la que ingresó ultima, lo hará la función en primer 
         lugar y luego la callback que fue llamada por la primera.
    </p>
    <a href="https://medium.com/noders/estructuras-de-datos-con-javascript-parte-1-pilas-stacks-5a2092cff16a">Fuente para consultar</a>
    
    <h4>A modo de resumen: La respuesta en modo sincróno ocurre en el presente. Se espera el resultado. </h4>

    <h2>Asíncrono</h2>
    <p>
        Hay ciertas instrucciones especiales que se "desvian" hacia un costado y esperan la respuesta de un sistema 
        remoto, y una vez que esa instrucción tiene la respuesta vuelve a la pila de ejacución.
        La gran mayoría son instrucciones síncronas. Muy pocas son asíncronas. Si debo esperar los resultados de 
        las operaciones asíncronas el código estará trabado hasta que llegue el resultado y poder continuar.
        Si se muestran los datos antes devuelve UNDEFINED.
    </p>

    <section id="orden"></section>
    <h4>A modo de resumen: La respuesta en modo asincróno sucede en el futuro. No se espera el resultado. </h4>
    <p>
        El comando setTimeout primero espera (tiempo en ms) y luego ejecuta la funcion (callback). 
         Si el tiempo es cero, sigue siendo de tipo asíncrona, o sea aunque sea cero el tiempo, sale igual
         y luego vuelve. 
    </p>

    <section id="forzarOrden1"></section>
    <section id="forzarOrden2"></section>
    <section id="forzarOrden3"></section>
    <section id="forzarOrden4"></section>
    <section id="tituloLaHora"></section>
    <section id="laHora">Son asl</section>
    <section>
        <h2>Ciclo de eventos - Event Loop</h2>
        <h3>¿Cómo funciona de manera interna el ENTORNO DE EJECUCION?</h3>
        <p>
            El entorno de ejecucion es el navegador (ejecuta JS), tambien esta el node
            (que ejecuta la tarea en JS) que es otro entorno de ejecución. Node es un motor 
            que no necesita un navegador para ejecutarse el código. 
        </p>
        <p>
            Tanto JS como Node tiene una misma forma de ejecutar las instrucciones: EVENT LOOP (Single Thread). 
            Es un loop de eventos de un solo hilo. Dentro del loop estan las partes sincronas, las partes
            asíncronas salen del loop a travez de un register callback hacia intensive operation u operaciones 
            intensivas que pueden ser operaciones con archivos, operaciones con base de datos u operaciones de cómputo (grandes). 
        </p>
        <p>
            Mientras tanto la página sigue funcionando hasta que lleguen las respuestas, "sigue funcionando" 
            esperando la respuesta o esperandola para que continue funcionando el sitio. Todo
            depende de como esté hecho la codificación. Si no está bien hecha el sitio puede provocar un fallo, 
            sea que se congele hasta que lleguen los datos o que los datos lancen un Undefined por no 
            contar con la fuente de datos. 
        </p>
        <p>
            Cuando la operacion se completo u Operation Complete, ingresa nuevamente al Event loop.
            Por medio de la Trigger Callback que se encarga de mostrar los datos (pueden ser productos) en la página,
             usando un request.
        </p>
        <a href="http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coInBhc2VvMSIpCnNldFRpbWVvdXQoY29uc29sZS5sb2coInBhc2VvIHNldCB0aW1lIiksMTAwMCk7CmNvbnNvbGUubG9nKCJwYXNlbzIiKQo%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">Puedes ver como funciona aquí</a>
        <p>Código de ejemplo: 
            <code>
                <pre>
                    $.on('button', 'click', function onClick() {
                        setTimeout(function timer() {
                            console.log("cliqueaste el boton");
                        }, 2000);
                    });

                    console.log("Hola");

                    setTimeout(function timeout() {
                        console.log("cliquee el boton");
                    }, 5000);

                    console.log("Bienvenido a loupe!");
                </pre>
            </code>
        </p>
        <h3>Código sincrono</h3>
        <p>
            Ni bien termina de ejecutar la instrucción sigue con la siguiente!
            El modelo síncrono utiliza el metodo LIFO: Last In First Out
            <code>
                <pre>
            console.log("Inicio");
            function dos() {
                console.log("dos");
            }

            function uno() {
                console.log("uno");
                dos();
                console.log("tres");
            }

            uno();
            console.log("Fin");
                </pre>
            </code>
        </p>

        <h3>Código asincrono</h3>
        <p>
            Las instrucciones se ejecutan en paralelo!
            El modelo asíncrono utiliza el metodo FIFO: First In First Out
            <code>
                <pre>
            console.log("Inicio");
            function dos() {
                setTimeout(function() {
                    console.log("dos");
                }, 1000)
                
            }

            function uno() {
                setTimeout(function() {
                    console.log("uno");
                },0);
                dos();
                console.log("tres");
            }

            uno();
            console.log("Fin");
                </pre>
            </code>
            El resultado es: Inicio, Tres, Fin, Uno, Dos.
        </p>
    </section>
    <section id="stack-colas">
        <h2>Pilas (stacks) vs. Colas (Queues)</h2>
        <p>En las pilas los datos se almacenan en la modalidad LIFO. 
            En las stacks se agrega un elemento con el método PUSH el cual se almacena
            y por decirlo de alguna manera queda en el "fondo del vaso", luego viene el 
            siguiente que se ubica por encima del anterior. Con el método POP se van 
            quitando solo el elemento que se encuentra arriba, no puedo sacar el que 
            se encuentra en el fondo, para ello primero tengo que quitar los demas.
            Ej: Una pila de platos para lavar.
        </p>
        <p>En las colas los datos se almacenan en la modalidad FIFO. 
            En las colas los datos se agregan con el método ENQUEUE desde atras hacia adelante, 
            y con el método DEQUEUE los elementos se van quitando, el elemento es el primero
            que ingresó. Ej: Una cola en un supermercado.
        </p>
    </section>
    <section>
        <h2>Peticiones y objetos de respuesta</h2>
        <p>
            Sería imposible que en nuestro proyecto se almacene toda la información que se 
            muestra, el sitio sería muy pesado. Para ello es conveniente conectarse a una 
            base de datos en un servidor remoto que mantiene la información actualizada y 
            de acceso constante para consultar ciertos datos de forma puntual 
            para luego poder mostrar tablas, tarjetas, imágenes en el sitio del proyecto. 
            La base de datos se mantiene sincronizada aun cuando distintos dispositivos acceden
            al sitio y solicitan un registro en especial. Toda esa información se mostrará de 
            la misma manera. Por medio de una API esto es posible.
        </p>
        <p>
            El modelo cliente-servidor: El cliente es el dispositivo particular desde donde 
            se peticiona y se accede a la informacion. El servidor será donde estan guardados
            los datos que por medio de una consulta serán entregados al cliente.
        </p>
        <p>
            Este tipo de páginas se denominan paginas dinámicas, porque estan en 
            constante cambio. En un portal de noticias es necesario porque la informacion 
            presentada cambia en forma constante. Si fuera estática siempre se mostraría 
            la misma noticia.
        </p>
    </section>
    <section>
        <h2>¿Que es una API?</h2>
        <p>
            Una API (Interfaz de Programación de Aplicaciones) es una conjunto de 
            definiciones y protocoles que se utilizan para desarrollar e integrar
            el software de las aplicaciones.
        </p>
        <p>
            La API es la forma de simplificar algo que es complejo. Una API que accede 
            a una base de datos con solo invocarla y un par de métodos puedo conectar o 
            desconectar a una BD. Internamente es un programa complejo que me permite
            acceder en forma remota a una BD. Ej: solicitar la lista de usuarios, para ello 
            se debe conectar al servidor, verificar ciertos valores, verificar los tiempos de 
            respuesta, enviar la consulta a la BD, utilizar ciertos protocolos de comunicación, 
            recibir la respuesta a esa consulta, legibilidad de los datos y mensajes de error. 
            En este ejemplo se puede apreciar de cierta manera el grado de complejidad.
        </p>
        <a href="https://jsonplaceholder.typicode.com/">Acceso a una API Rest</a>
    </section>
    <section>
        <h2>¿Qué es un END POINT?</h2>
        <p>
            Cualquier dispositivo conectado a la red puede ser un End Point. El único requisito
            para ser un end point es que la comunicacion debe terninar en ese dispositivo. Ej:
            pido un dato, el dispositivo end point es el servidor donde se hace la peticion y 
            el dispositivo que se pide la informacion es otro end point.
        </p>
        <p>
            Los End Points se programan en el backend. El backend es todo lo relativo al servidor.
            Todo lo que esta por detras de la página. La Siguiente página es un backend.
        </p>
        <p>
            Esta direccion https://jsonplaceholder.typicode.com/users es un end point. Devuelve recursos.
        </p>
        <p>
            Una diferencia con los objetos de JS y JSon es que los atributos van entre comillas: JSON
            <code>
                <pre>
                    {
                        "id": 1,
                        "name": "Leanne Graham",
                        "username": "Bret",
                        "email": "Sincere@april.biz",
                        "address": {
                          "street": "Kulas Light",
                          "suite": "Apt. 556",
                          "city": "Gwenborough",
                          "zipcode": "92998-3874",
                          "geo": {
                            "lat": "-37.3159",
                            "lng": "81.1496"
                          }
                        },
                        "phone": "1-770-736-8031 x56442",
                        "website": "hildegard.org",
                        "company": {
                          "name": "Romaguera-Crona",
                          "catchPhrase": "Multi-layered client-server neural-net",
                          "bs": "harness real-time e-markets"
                        }
                      }
                </pre>
            </code>
        </p>
        <p>
            Una extension para ver el formato JSON <a href="https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa/related">Ver JSON en Firefox / Brave</a>
        </p>
    </section>
    <section>
        <h2>El objeto XMLHTTPRequest</h2>
        <p>Antiguamente las peticiones en JS se realizaban por medio de una instancia
            del objeto XMLHTTPRequest, el mismo nos permitía acceder a propiedades con 
            informacion relativa al endpoint con el que deseamos conectarnos. Esta forma
            demandaba muchas líneas de código incluso para realizar las peticiones más 
            simples.
        </p>
        <code>
            <pre>
                var url = "https://address.com/user";
                var token = "miTokenEnMD5"

                var xhrConnection = new XMLHttpRequest();

                xhrConnection.open('GET', url);

                xhrConnection.setRequestHeader('Authorization', 'token ' + token);

                xhrConnection.send(null);
            </pre>
        </code>
    </section>
    <section>
        <h2>El objeto fetch</h2>
        <p>
            Desde el año 2015 apareció el método fetch(), que reemplazaba al objeto 
            XMLHTTPRequest, simplificando la tarea. Fetch significa "alcanzar" (información).
        </p>
        <p>
            Este método nos permite conectarnos a un endpoint y obtener un objeto de 
            respuesta. 
        </p>
        <p>
            Fetch utiliza las promesas. ¿Que hace fetch? Fetch pide la información, y luego 
            (¿que hago con esos datos?) muestro la respuesta por la consola en caso de éxito, 
            de lo contrario capturo y muestro el error.
            De esta forma estructuro lo que es una promesa.
            <code>
                <pre>
        fetch('https://jsonplaceholder.typicode.com/users')  //pido info
            .then(respuesta=>console.log(respuesta))   //exito: muestro la respuesta por consola
            .catch(error=>console.log(error))  //capturo y muestro el error
                </pre>
            </code>
        </p>
        <p>Muestro el resultado exitoso:</p>
        <p id="resultadoPromesa"></p>
        <p>Muestro el resultado erroneo:</p>
        <p id="resultadoFracaso"></p>
        <p>Muestro el resultado por consola:</p>
        <p id="resultadoConsola">Ver la consola</p>

    
    </section>
    <section>
        <h2>Muestro los usuarios desde 'https://jsonplaceholder.typicode.com/users'</h2>
        <div id="contenedorUsuarios">console.log(data[0].name));</div>
        <p>De nuevo: Existe un método en JS llamado fetch(). Este método nos permite
            conectarnos con un endpoint (usuarios del sitio jsonplaceholder), y como 
            respuesta obtener un objeto. En este caso, el endpoint corresponde a una API 
            gratuita disponible en internet que brinda usuarios aleatorios.
        </p>
        <h3>Códigos de estado de respuesta HTTP</h3>
        <p>
            <ul>
                <li>100 a 199 - Respuesta informativas</li>
                <li>200 a 299 - Respuesta satisfactorias</li>
                <li>300 a 399 - Redirecciones</li>
                <li>400 a 499 - Errores de los clientes</li>
                <li>500 a 599 - Errores de los servidores</li>
            </ul>
        </p>
    </section>



    <script src="./index.js"></script>
    <script src="./cuento.js"></script>
    <script src="./asincrono01.js"></script>
    <script src="./asincrono02.js"></script>
    <script src="./fetch.js"></script>
</body>
</html>